[General]
sim-time-limit=600s
num-rngs = 1
seed-0-mt = 5
output-scalar-file-append = false
**.vector-recording = true
record-eventlog = false

*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true

#num-rngs = 2

**.tcpType = "TCP"

# tcp general settings
**.tcp.advertisedWindow = 65535                      # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.delayedAcksEnabled = false                    # delayed ACK algorithm (RFC 1122) enabled/disabled
**.tcp.nagleEnabled = true                           # Nagle's algorithm (RFC 896) enabled/disabled
**.tcp.limitedTransmitEnabled = false                # Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)
**.tcp.increasedIWEnabled = false                    # Increased Initial Window (RFC 3390) enabled/disabled
**.tcp.sackSupport = false                           # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
**.tcp.windowScalingSupport = false                  # Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)
**.tcp.timestampSupport = false                      # Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)
**.tcp.mss = 1452                                    # Maximum Segment Size (RFC 793) (header option)
**.tcp.tcpAlgorithmClass = "TcpReno"                 # TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP
**.tcp.recordStats = false 							 # recording of seqNum etc. into output vectors enabled/disable

**.transmissionState.result-recording-modes = -vector
**.queueLength.result-recording-modes = -vector
**.queueingTime.result-recording-modes = -vector
**.ppp[*].queue.packetReceived.result-recording-modes = -vector(packetBytes)
**.tcpRcvQueueBytes.result-recording-modes = -vector

[Config oneAppTest]
description = "An extension of the simple router test which includes 2 links between central routers, but 4 hosts and 4 servers in the network"
network = simple4HostTestNet
#**.fcsMode = "declared"
**.crcMode = "computed"
#*.*.ipv4.ip.crcMode = "computed"
#**.udp.crcMode = "disabled"

*.configurator.config = xmldoc("routerConfig4Hosts.xml")
*.configurator.optimizeRoutes = false

## File download client
#*.stdHost3.numApps = 1
#*.stdHost3.app[0].typename = "TcpFileDownloadApp"
#*.stdHost3.app[0].localAddress = ""
#*.stdHost3.app[0].localPort = -1 # port number to listen on
##*.stdHost0.app[0].connectAddress = "server0" # server address (may be symbolic)
##*.stdHost1.app[0].connectAddress = "server1" # server address (may be symbolic)
##*.stdHost2.app[0].connectAddress = "server2" # server address (may be symbolic)
#*.stdHost3.app[0].connectAddress = "server3" # server address (may be symbolic)
#*.stdHost3.app[0].connectPort = 1042 # port number to connect to
#*.stdHost3.app[0].startTime = 0.01s # time first session begins
#*.stdHost3.app[0].stopTime = -1s # time of finishing sending, negative values mean forever
#*.stdHost3.app[0].numRequestsPerSession = 1 # number of requests sent per session
#*.stdHost3.app[0].requestLength = 200B # length of a request
#*.stdHost3.app[0].replyLength = 10MiB # length of a reply
#*.stdHost3.app[0].thinkTime = 0.01s # time gap between requests
#*.stdHost3.app[0].idleInterval = 10s # time gap between sessions
#*.stdHost3.app[0].reconnectInterval = 3s # if connection breaks, waits this much before trying to reconnect
#*.stdHost3.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
#*.stdHost3.app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation
#
## File download server
#*.server3.numApps = 1
#*.server3.app[0].typename = "TcpGenericServerApp"
#*.server3.app[0].localAddress = "" # local address; may be left empty ("")
#*.server3.app[0].localPort = 1042 # localPort number to listen on
#*.server3.app[0].replyDelay = 0s #
#*.server3.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
#*.server3.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

## Remote Shell
#**.stdHost2.numApps = 1
#**.stdHost2.app[0].typename = "TcpSimpleSshApp"
#**.stdHost2.app[0].localAddress = "" # local address or empty ("")
#**.stdHost2.app[0].localPort = -1 # local port number
#**.stdHost2.app[0].connectAddress = "server2" # server address (may be symbolic)
#**.stdHost2.app[0].connectPort = 22 # port number to connect to
#**.stdHost2.app[0].startTime = 0.01s # time first session begins
#**.stdHost2.app[0].stopTime = -1s # time of finishing sending, negative values mean forever
#**.stdHost2.app[0].numCommands = int(uniform(1,10)) # user types this many commands in a session
#**.stdHost2.app[0].commandLength = 10B # commands are this many characters (plus Enter)
#**.stdHost2.app[0].keyPressDelay = uniform(0.01s,0.02s) # delay between keypresses
#**.stdHost2.app[0].commandOutputLength = 500B # commands produce this much output
#**.stdHost2.app[0].thinkTime = uniform(0.5s,1s) # user waits this much before starting to type new command
#**.stdHost2.app[0].idleInterval = uniform(1s,2s) # time gap between sessions
#**.stdHost2.app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
#**.stdHost2.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
#**.stdHost2.app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation
#
## Telnet server
#*.server2.numApps = 1
#*.server2.app[0].typename = "TcpGenericServerApp"
#*.server2.app[0].localAddress = "" # local address; may be left empty ("")
#*.server2.app[0].localPort = 22 # localPort number to listen on
#*.server2.app[0].replyDelay = 0s #
#*.server2.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
#*.server2.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost1.numApps = 1
**.stdHost1.app[0].typename = "TCPVideoStreamCliApp"
**.stdHost1.app[0].localAddress = "" # may be left empty ("")
**.stdHost1.app[0].localPort = -1 # port number to listen on
**.stdHost1.app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost1.app[0].connectPort = 1042 # port number to connect to
**.stdHost1.app[0].dataTransferMode = "object"
**.stdHost1.app[0].startTime = 0.01s # time first session begins
**.stdHost1.app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost1.app[0].idleInterval = 10s
**.stdHost1.app[0].requestLength = 200B # length of a request
**.stdHost1.app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost1.app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost1.app[0].thinkTime = 1000s # time gap between requests
**.stdHost1.app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost1.app[0].manifest_size = 100000
**.stdHost1.app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost1.app[0].video_duration = 500s # video length in seconds
**.stdHost1.app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.numApps = 1
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config simple4App4HostTest]
description = "An extension of the simple router test which includes 2 links between central routers, but 4 hosts and 4 servers in the network"
network = simple4HostTestNet
#**.fcsMode = "declared"
**.crcMode = "computed"
#*.*.ipv4.ip.crcMode = "computed"
#**.udp.crcMode = "disabled"

*.configurator.config = xmldoc("routerConfig4Hosts.xml")
*.configurator.optimizeRoutes = false

#*.router0.numPcapRecorders = 6
#*.router1.numPcapRecorders = 1
#*.stdHost*.numPcapRecorders = 1
#*.server*.numPcapRecorders = 1
#*.*.pcapRecorder[*].pcapNetwork = 204
#*.s*.pcapRecorder[*].moduleNamePatterns = "ppp[*]"
#*.*.pcapRecorder[*].alwaysFlush = true 
#*.stdHost0.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/stdHost0.pcap"
#*.stdHost1.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/stdHost1.pcap"
#*.stdHost2.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/stdHost2.pcap"
#*.stdHost3.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/stdHost3.pcap"
#*.server0.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/server0.pcap"
#*.server1.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/server1.pcap"
#*.server2.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/server2.pcap"
#*.server3.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/server3.pcap"
#
#*.router0.pcapRecorder[0].pcapFile = "results/simple4App4HostTest/router0ppp0.pcap"
#*.router0.pcapRecorder[1].pcapFile = "results/simple4App4HostTest/router0ppp1.pcap"
#*.router0.pcapRecorder[2].pcapFile = "results/simple4App4HostTest/router0ppp2.pcap"
#*.router0.pcapRecorder[3].pcapFile = "results/simple4App4HostTest/router0ppp3.pcap"
#*.router0.pcapRecorder[4].pcapFile = "results/simple4App4HostTest/router0ppp4.pcap"
#*.router0.pcapRecorder[5].pcapFile = "results/simple4App4HostTest/router0ppp5.pcap"
#*.router0.pcapRecorder[0].moduleNamePatterns = "ppp[0]"
#*.router0.pcapRecorder[1].moduleNamePatterns = "ppp[1]"
#*.router0.pcapRecorder[2].moduleNamePatterns = "ppp[2]"
#*.router0.pcapRecorder[3].moduleNamePatterns = "ppp[3]"
#*.router0.pcapRecorder[4].moduleNamePatterns = "ppp[4]"
#*.router0.pcapRecorder[5].moduleNamePatterns = "ppp[5]"
#
#*.router1.pcapRecorder[*].pcapFile = "results/simple4App4HostTest/router1.pcap"
#*.router1.pcapRecorder[*].moduleNamePatterns = "ppp[*]"

# File download client
*.stdHost*.numApps = 1
*.stdHost3.app[0].typename = "TcpFileDownloadApp"
*.stdHost3.app[0].localAddress = ""
*.stdHost3.app[0].localPort = -1 # port number to listen on
#*.stdHost0.app[0].connectAddress = "server0" # server address (may be symbolic)
#*.stdHost1.app[0].connectAddress = "server1" # server address (may be symbolic)
#*.stdHost2.app[0].connectAddress = "server2" # server address (may be symbolic)
*.stdHost3.app[0].connectAddress = "server3" # server address (may be symbolic)
*.stdHost3.app[0].connectPort = 1042 # port number to connect to
*.stdHost3.app[0].startTime = 0.01s # time first session begins
*.stdHost3.app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost3.app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost3.app[0].requestLength = 200B # length of a request
*.stdHost3.app[0].replyLength = 10MiB # length of a reply
*.stdHost3.app[0].thinkTime = 0.01s # time gap between requests
*.stdHost3.app[0].idleInterval = 10s # time gap between sessions
*.stdHost3.app[0].reconnectInterval = 3s # if connection breaks, waits this much before trying to reconnect
*.stdHost3.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost3.app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server
*.server*.numApps = 1
*.server{1,3}.app[0].typename = "TcpGenericServerApp"
*.server{1,3}.app[0].localAddress = "" # local address; may be left empty ("")
*.server{1,3}.app[0].localPort = 1042 # localPort number to listen on
*.server{1,3}.app[0].replyDelay = 0s #
*.server{1,3}.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server{1,3}.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# VoIP receiver
**.stdHost0.app[0].typename = "SimpleVoipReceiver"
**.stdHost0.app[0].localPort = 2000
**.stdHost0.app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost0.app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost0.app[0].emodelA = 5 # Advantage factor
**.stdHost0.app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost0.app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost0.app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost0.app[0].bufferSpace = 20 # buffer size in packets
**.stdHost0.app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server0.app[0].typename = "SimpleVoipSender"
**.server0.app[0].localPort = -1
**.server0.app[0].destPort = 2000
**.server0.app[0].destAddress = "stdHost0"
**.server0.app[0].talkPacketSize = 40B # size of talk packets in bytes
**.server0.app[0].talkspurtDuration = weibull(1.423s, 0.824s)
**.server0.app[0].silenceDuration = weibull(0.899s, 1.089s)
**.server0.app[0].packetizationInterval = 1ms # interval between sending voice packets
**.server0.app[0].startTime = 0.01s # time of start sending
**.server0.app[0].stopTime = -1s # time of end of sending, -1 means forever

# Video client
**.stdHost1.app[0].typename = "TCPVideoStreamCliApp"
**.stdHost1.app[0].localAddress = "" # may be left empty ("")
**.stdHost1.app[0].localPort = -1 # port number to listen on
**.stdHost1.app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost1.app[0].connectPort = 1042 # port number to connect to
**.stdHost1.app[0].dataTransferMode = "bytestream"
**.stdHost1.app[0].startTime = 0.01s # time first session begins
**.stdHost1.app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost1.app[0].idleInterval = 1000s
**.stdHost1.app[0].requestLength = 200B # length of a request
**.stdHost1.app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost1.app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost1.app[0].thinkTime = 1000s # time gap between requests
**.stdHost1.app[0].video_packet_size_per_second = "1000 1500 2000 4000 8000 12000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost1.app[0].manifest_size = 100000
**.stdHost1.app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost1.app[0].video_duration = 300s # video length in seconds
**.stdHost1.app[0].segment_length = 5s # video segment length in seconds

# Remote Shell
**.stdHost2.app[0].typename = "TcpSimpleSshApp"
**.stdHost2.app[0].localAddress = "" # local address or empty ("")
**.stdHost2.app[0].localPort = -1 # local port number
**.stdHost2.app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost2.app[0].connectPort = 22 # port number to connect to
**.stdHost2.app[0].startTime = 0.01s # time first session begins
**.stdHost2.app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost2.app[0].numCommands = int(uniform(1,10)) # user types this many commands in a session
**.stdHost2.app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost2.app[0].keyPressDelay = uniform(0.01s,0.02s) # delay between keypresses
**.stdHost2.app[0].commandOutputLength = intWithUnit(uniform(500B,1000B)) # commands produce this much output
**.stdHost2.app[0].thinkTime = uniform(0.5s,1s) # user waits this much before starting to type new command
**.stdHost2.app[0].idleInterval = uniform(1s,2s) # time gap between sessions
**.stdHost2.app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost2.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost2.app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# Telnet server
*.server2.app[0].typename = "TcpGenericServerApp"
*.server2.app[0].localAddress = "" # local address; may be left empty ("")
*.server2.app[0].localPort = 22 # localPort number to listen on
*.server2.app[0].replyDelay = 0s #
*.server2.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation