[General]
sim-time-limit=250s
num-rngs = 1
seed-0-mt = 5
output-scalar-file-append = false
**.vector-recording = true
record-eventlog = false

*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true

#num-rngs = 2

**.tcpType = "TCP"

# tcp general settings
**.tcp.advertisedWindow = 65535                      # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.delayedAcksEnabled = false                    # delayed ACK algorithm (RFC 1122) enabled/disabled
**.tcp.nagleEnabled = true                           # Nagle's algorithm (RFC 896) enabled/disabled
**.tcp.limitedTransmitEnabled = false                # Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)
**.tcp.increasedIWEnabled = false                    # Increased Initial Window (RFC 3390) enabled/disabled
**.tcp.sackSupport = false                           # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
**.tcp.windowScalingSupport = false                  # Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)
**.tcp.timestampSupport = false                      # Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)
**.tcp.mss = 1452                                    # Maximum Segment Size (RFC 793) (header option)
**.tcp.tcpAlgorithmClass = "TcpReno"                 # TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP
#**.tcp.recordStats = true 							 # recording of seqNum etc. into output vectors enabled/disable

**.transmissionState.result-recording-modes = -vector
**.queueLength.result-recording-modes = -vector
**.queueingTime.result-recording-modes = -vector
**.ppp[*].queue.packetReceived.result-recording-modes = -vector(packetBytes)
**.tcpRcvQueueBytes.result-recording-modes = -vector

[Config baselineTestNoSSH10]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=30}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..9].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..9].app[0].localAddress = ""
*.stdHost[0..9].app[0].localPort = -1 # port number to listen on
*.stdHost[0..9].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..9].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..9].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..9].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..9].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..9].app[0].requestLength = 800B # length of a request
*.stdHost[0..9].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..9].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..9].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..9].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..9].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..9].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[10..19].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[10..19].app[0].localAddress = "" # may be left empty ("")
**.stdHost[10..19].app[0].localPort = -1 # port number to listen on
**.stdHost[10..19].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[10..19].app[0].connectPort = 1042 # port number to connect to
**.stdHost[10..19].app[0].dataTransferMode = "object"
**.stdHost[10..19].app[0].startTime = 0.01s # time first session begins
**.stdHost[10..19].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[10..19].app[0].idleInterval = 1s
**.stdHost[10..19].app[0].requestLength = 200B # length of a request
**.stdHost[10..19].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[10..19].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[10..19].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[10..19].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[10..19].app[0].manifest_size = 100000
**.stdHost[10..19].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[10..19].app[0].video_duration = 300s # video length in seconds
**.stdHost[10..19].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.numApps = 0

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false

# VoIP receiver
**.stdHost[20..29].app[0].typename = "SimpleVoipReceiver"
**.stdHost[20..29].app[0].localPort = 2000
**.stdHost[20..29].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[20..29].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[20..29].app[0].emodelA = 5 # Advantage factor
**.stdHost[20..29].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[20..29].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[20..29].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[20..29].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[20..29].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server3.numApps = 10
**.server3.app[*].typename = "SimpleVoipSender"
**.server3.app[*].localPort = -1
**.server3.app[*].destPort = 2000
**.server3.app[*].destAddress = "stdHost[" + string(20 + index()) + "]"
**.server3.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server3.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server3.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server3.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server3.app[*].startTime = 0.01s # time of start sending
**.server3.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config baselineTestNoSSH20]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=60}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..19].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..19].app[0].localAddress = ""
*.stdHost[0..19].app[0].localPort = -1 # port number to listen on
*.stdHost[0..19].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..19].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..19].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..19].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..19].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..19].app[0].requestLength = 800B # length of a request
*.stdHost[0..19].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..19].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..19].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..19].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..19].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..19].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[20..39].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[20..39].app[0].localAddress = "" # may be left empty ("")
**.stdHost[20..39].app[0].localPort = -1 # port number to listen on
**.stdHost[20..39].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[20..39].app[0].connectPort = 1042 # port number to connect to
**.stdHost[20..39].app[0].dataTransferMode = "object"
**.stdHost[20..39].app[0].startTime = 0.01s # time first session begins
**.stdHost[20..39].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[20..39].app[0].idleInterval = 1s
**.stdHost[20..39].app[0].requestLength = 200B # length of a request
**.stdHost[20..39].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[20..39].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[20..39].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[20..39].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[20..39].app[0].manifest_size = 100000
**.stdHost[20..39].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[20..39].app[0].video_duration = 300s # video length in seconds
**.stdHost[20..39].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.numApps = 0

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false

# VoIP receiver
**.stdHost[40..59].app[0].typename = "SimpleVoipReceiver"
**.stdHost[40..59].app[0].localPort = 2000
**.stdHost[40..59].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[40..59].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[40..59].app[0].emodelA = 5 # Advantage factor
**.stdHost[40..59].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[40..59].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[40..59].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[40..59].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[40..59].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server3.numApps = 20
**.server3.app[*].typename = "SimpleVoipSender"
**.server3.app[*].localPort = -1
**.server3.app[*].destPort = 2000
**.server3.app[*].destAddress = "stdHost[" + string(40 + index()) + "]"
**.server3.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server3.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server3.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server3.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server3.app[*].startTime = 0.01s # time of start sending
**.server3.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config baselineTestNoSSH30]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=90}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..29].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..29].app[0].localAddress = ""
*.stdHost[0..29].app[0].localPort = -1 # port number to listen on
*.stdHost[0..29].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..29].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..29].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..29].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..29].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..29].app[0].requestLength = 800B # length of a request
*.stdHost[0..29].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..29].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..29].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..29].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..29].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..29].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[30..59].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[30..59].app[0].localAddress = "" # may be left empty ("")
**.stdHost[30..59].app[0].localPort = -1 # port number to listen on
**.stdHost[30..59].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[30..59].app[0].connectPort = 1042 # port number to connect to
**.stdHost[30..59].app[0].dataTransferMode = "object"
**.stdHost[30..59].app[0].startTime = 0.01s # time first session begins
**.stdHost[30..59].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[30..59].app[0].idleInterval = 1s
**.stdHost[30..59].app[0].requestLength = 200B # length of a request
**.stdHost[30..59].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[30..59].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[30..59].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[30..59].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[30..59].app[0].manifest_size = 100000
**.stdHost[30..59].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[30..59].app[0].video_duration = 300s # video length in seconds
**.stdHost[30..59].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 0

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false

# VoIP receiver
**.stdHost[60..89].app[0].typename = "SimpleVoipReceiver"
**.stdHost[60..89].app[0].localPort = 2000
**.stdHost[60..89].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[60..89].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[60..89].app[0].emodelA = 5 # Advantage factor
**.stdHost[60..89].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[60..89].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[60..89].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[60..89].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[60..89].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server3.numApps = 30
**.server3.app[*].typename = "SimpleVoipSender"
**.server3.app[*].localPort = -1
**.server3.app[*].destPort = 2000
**.server3.app[*].destAddress = "stdHost[" + string(60 + index()) + "]"
**.server3.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server3.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server3.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server3.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server3.app[*].startTime = 0.01s # time of start sending
**.server3.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config baselineTestNoSSH40]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=120}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..39].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..39].app[0].localAddress = ""
*.stdHost[0..39].app[0].localPort = -1 # port number to listen on
*.stdHost[0..39].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..39].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..39].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..39].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..39].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..39].app[0].requestLength = 800B # length of a request
*.stdHost[0..39].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..39].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..39].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..39].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..39].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..39].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[40..79].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[40..79].app[0].localAddress = "" # may be left empty ("")
**.stdHost[40..79].app[0].localPort = -1 # port number to listen on
**.stdHost[40..79].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[40..79].app[0].connectPort = 1042 # port number to connect to
**.stdHost[40..79].app[0].dataTransferMode = "object"
**.stdHost[40..79].app[0].startTime = 0.01s # time first session begins
**.stdHost[40..79].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[40..79].app[0].idleInterval = 1s
**.stdHost[40..79].app[0].requestLength = 200B # length of a request
**.stdHost[40..79].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[40..79].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[40..79].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[40..79].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[40..79].app[0].manifest_size = 100000
**.stdHost[40..79].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[40..79].app[0].video_duration = 300s # video length in seconds
**.stdHost[40..79].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.numApps = 0

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false

# VoIP receiver
**.stdHost[80..119].app[0].typename = "SimpleVoipReceiver"
**.stdHost[80..119].app[0].localPort = 2000
**.stdHost[80..119].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[80..119].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[80..119].app[0].emodelA = 5 # Advantage factor
**.stdHost[80..119].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[80..119].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[80..119].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[80..119].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[80..119].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server3.numApps = 40
**.server3.app[*].typename = "SimpleVoipSender"
**.server3.app[*].localPort = -1
**.server3.app[*].destPort = 2000
**.server3.app[*].destAddress = "stdHost[" + string(80 + index()) + "]"
**.server3.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server3.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server3.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server3.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server3.app[*].startTime = 0.01s # time of start sending
**.server3.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config baselineTestNoSSH50]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=150}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..49].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..49].app[0].localAddress = ""
*.stdHost[0..49].app[0].localPort = -1 # port number to listen on
*.stdHost[0..49].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..49].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..49].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..49].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..49].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..49].app[0].requestLength = 800B # length of a request
*.stdHost[0..49].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..49].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..49].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..49].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..49].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..49].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[50..99].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[50..99].app[0].localAddress = "" # may be left empty ("")
**.stdHost[50..99].app[0].localPort = -1 # port number to listen on
**.stdHost[50..99].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[50..99].app[0].connectPort = 1042 # port number to connect to
**.stdHost[50..99].app[0].dataTransferMode = "object"
**.stdHost[50..99].app[0].startTime = 0.01s # time first session begins
**.stdHost[50..99].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[50..99].app[0].idleInterval = 1s
**.stdHost[50..99].app[0].requestLength = 200B # length of a request
**.stdHost[50..99].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[50..99].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[50..99].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[50..99].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[50..99].app[0].manifest_size = 100000
**.stdHost[50..99].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[50..99].app[0].video_duration = 300s # video length in seconds
**.stdHost[50..99].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.numApps = 0

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false

# VoIP receiver
**.stdHost[100..149].app[0].typename = "SimpleVoipReceiver"
**.stdHost[100..149].app[0].localPort = 2000
**.stdHost[100..149].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[100..149].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[100..149].app[0].emodelA = 5 # Advantage factor
**.stdHost[100..149].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[100..149].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[100..149].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[100..149].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[100..149].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server3.numApps = 50
**.server3.app[*].typename = "SimpleVoipSender"
**.server3.app[*].localPort = -1
**.server3.app[*].destPort = 2000
**.server3.app[*].destAddress = "stdHost[" + string(100 + index()) + "]"
**.server3.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server3.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server3.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server3.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server3.app[*].startTime = 0.01s # time of start sending
**.server3.app[*].stopTime = -1s # time of end of sending, -1 means forever