[General]
sim-time-limit=250s
num-rngs = 1
seed-0-mt = 5
output-scalar-file-append = false
**.vector-recording = true
record-eventlog = false

*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true

#num-rngs = 2

**.tcpType = "TCP"

# tcp general settings
**.tcp.advertisedWindow = 65535                      # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.delayedAcksEnabled = false                    # delayed ACK algorithm (RFC 1122) enabled/disabled
**.tcp.nagleEnabled = true                           # Nagle's algorithm (RFC 896) enabled/disabled
**.tcp.limitedTransmitEnabled = false                # Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)
**.tcp.increasedIWEnabled = false                    # Increased Initial Window (RFC 3390) enabled/disabled
**.tcp.sackSupport = false                           # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
**.tcp.windowScalingSupport = false                  # Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)
**.tcp.timestampSupport = true                      # Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)
**.tcp.mss = 1452                                    # Maximum Segment Size (RFC 793) (header option)
**.tcp.tcpAlgorithmClass = "TcpReno"                 # TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP
**.tcp.recordStats = false 							 # recording of seqNum etc. into output vectors enabled/disable

**.transmissionState.result-recording-modes = -vector
**.queueLength.result-recording-modes = -vector
**.queueingTime.result-recording-modes = -vector
**.ppp[*].queue.packetReceived.result-recording-modes = -vector(packetBytes)
**.tcpRcvQueueBytes.result-recording-modes = -vector

[Config tcpVideoClientTest]
description = "Link utilization test with TCP Video Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTestV2]
description = "Link utilization test with TCP Video Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTestV3a]
description = "Link utilization test with TCP Video Client Application and non-flexible bitrate"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,240,250,260,270,280,290,300}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds
**.stdHost[*].app[0].useFlexibleBitrate = "non-flexible"

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTestV3b]
description = "Link utilization test with TCP Video Client Application and flexible bitrate"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,240,250,260,270,280,290,300}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds
**.stdHost[*].app[0].useFlexibleBitrate = "flexible"

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTest_ext1]
description = "Link utilization test with TCP Video Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=2,4,6,8,12,14,16,18,22,24,26,28,32,34,36,38}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTest_ext2]
description = "Link utilization test with TCP Video Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=102,104,106,108,112,114,116,118,122,124,126,128}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config tcpVideoClientTest_ext3]
description = "Link utilization test with TCP Video Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=230,240,250,260,270,280,290,300}
**.conn1.delay = 1ms

# Video client
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[*].app[0].localAddress = "" # may be left empty ("")
**.stdHost[*].app[0].localPort = -1 # port number to listen on
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 1042 # port number to connect to
**.stdHost[*].app[0].dataTransferMode = "object"
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[*].app[0].idleInterval = 1000s
**.stdHost[*].app[0].requestLength = 200B # length of a request
**.stdHost[*].app[0].reconnectInterval = 10s # if connection breaks, waits this much before trying to reconnect
**.stdHost[*].app[0].numRequestsPerSession = 2 # number of requests sent per session
**.stdHost[*].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[*].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[*].app[0].manifest_size = 100000
**.stdHost[*].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[*].app[0].video_duration = 100s # video length in seconds
**.stdHost[*].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config fileDownloadClientTest]
description = "Link utilization test with File Download Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,2,3,4,5,6,7,8,9,10,11,12}#,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40}
**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.stdHost[*].app[0].typename = "TcpFileDownloadApp"
*.stdHost[*].app[0].localAddress = ""
*.stdHost[*].app[0].localPort = -1 # port number to listen on
*.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
*.stdHost[*].app[0].connectPort = 1042 # port number to connect to
*.stdHost[*].app[0].startTime = 0.01s # time first session begins
*.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[*].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[*].app[0].requestLength = 800B # length of a request
*.stdHost[*].app[0].replyLength = 50MiB # length of a reply
*.stdHost[*].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[*].app[0].idleInterval = 1000s # time gap between sessions
*.stdHost[*].app[0].reconnectInterval = 3s # if connection breaks, waits this much before trying to reconnect
*.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config fileDownloadClientTest_ext1]
description = "Link utilization test with File Download Client Application"
network = simpleNHost1ServerLinkUtilizationTest
sim-time-limit=600s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=60,80,100}
**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.stdHost[*].app[0].typename = "TcpFileDownloadApp"
*.stdHost[*].app[0].localAddress = ""
*.stdHost[*].app[0].localPort = -1 # port number to listen on
*.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
*.stdHost[*].app[0].connectPort = 1042 # port number to connect to
*.stdHost[*].app[0].startTime = 0.01s # time first session begins
*.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[*].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[*].app[0].requestLength = 800B # length of a request
*.stdHost[*].app[0].replyLength = 50MiB # length of a reply
*.stdHost[*].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[*].app[0].idleInterval = 1000s # time gap between sessions
*.stdHost[*].app[0].reconnectInterval = 3s # if connection breaks, waits this much before trying to reconnect
*.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 1042 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config sshClientTest]
description = "Link utilization test with SSH Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,5,10,15,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300}
**.conn1.delay = 1ms

# Remote Shell
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TcpSimpleSshApp"
**.stdHost[*].app[0].localAddress = "" # local address or empty ("")
**.stdHost[*].app[0].localPort = -1 # local port number
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 22 # port number to connect to
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[*].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[*].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[*].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[*].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[*].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[*].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[*].app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 22 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config sshClientTest_ext1]
description = "Link utilization test with SSH Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1000,1500,2000,2500,3000,3500,4000}
**.conn1.delay = 1ms

# Remote Shell
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TcpSimpleSshApp"
**.stdHost[*].app[0].localAddress = "" # local address or empty ("")
**.stdHost[*].app[0].localPort = -1 # local port number
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 22 # port number to connect to
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[*].app[0].numCommands = int(uniform(1,10)) # user types this many commands in a session
**.stdHost[*].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[*].app[0].keyPressDelay = uniform(0.01s,0.02s) # delay between keypresses
**.stdHost[*].app[0].commandOutputLength = intWithUnit(uniform(500B,1000B)) # commands produce this much output
**.stdHost[*].app[0].thinkTime = uniform(0.5s,1s) # user waits this much before starting to type new command
**.stdHost[*].app[0].idleInterval = uniform(1s,2s) # time gap between sessions
**.stdHost[*].app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 22 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config sshClientTestV2]
description = "Link utilization test with SSH Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,50}
**.conn1.delay = ${setDelay=10,100,1000,10000,100000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000,11000000,12000000,13000000,14000000,15000000,16000000,17000000,18000000,19000000,20000000}ns

# Remote Shell
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TcpSimpleSshApp"
**.stdHost[*].app[0].localAddress = "" # local address or empty ("")
**.stdHost[*].app[0].localPort = -1 # local port number
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 22 # port number to connect to
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[*].app[0].numCommands = int(uniform(1,10)) # user types this many commands in a session
**.stdHost[*].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[*].app[0].keyPressDelay = uniform(0.01s,0.02s) # delay between keypresses
**.stdHost[*].app[0].commandOutputLength = intWithUnit(uniform(500B,1000B)) # commands produce this much output
**.stdHost[*].app[0].thinkTime = uniform(0.5s,1s) # user waits this much before starting to type new command
**.stdHost[*].app[0].idleInterval = uniform(1s,2s) # time gap between sessions
**.stdHost[*].app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 22 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config sshClientTestV2_ext1]
description = "Link utilization test with SSH Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,50}
**.conn1.delay = ${setDelay=30000000,40000000,50000000,60000000,70000000,80000000,90000000,100000000,200000000,300000000,400000000,500000000,1000000000}ns

# Remote Shell
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TcpSimpleSshApp"
**.stdHost[*].app[0].localAddress = "" # local address or empty ("")
**.stdHost[*].app[0].localPort = -1 # local port number
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 22 # port number to connect to
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[*].app[0].numCommands = int(uniform(1,10)) # user types this many commands in a session
**.stdHost[*].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[*].app[0].keyPressDelay = uniform(0.01s,0.02s) # delay between keypresses
**.stdHost[*].app[0].commandOutputLength = intWithUnit(uniform(500B,1000B)) # commands produce this much output
**.stdHost[*].app[0].thinkTime = uniform(0.5s,1s) # user waits this much before starting to type new command
**.stdHost[*].app[0].idleInterval = uniform(1s,2s) # time gap between sessions
**.stdHost[*].app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 22 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config sshClientTestV3]
description = "Link utilization test with SSH Client Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,50}
**.conn1.delay = ${setDelay=10,100,1000,10000,100000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000,11000000,12000000,13000000,14000000,15000000,16000000,17000000,18000000,19000000,20000000,30000000,40000000,50000000,60000000,70000000,80000000,90000000,100000000,200000000,300000000,400000000,500000000,600000000,700000000,800000000,900000000,1000000000}ns

# Remote Shell
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "TcpSimpleSshApp"
**.stdHost[*].app[0].localAddress = "" # local address or empty ("")
**.stdHost[*].app[0].localPort = -1 # local port number
**.stdHost[*].app[0].connectAddress = "server" # server address (may be symbolic)
**.stdHost[*].app[0].connectPort = 22 # port number to connect to
**.stdHost[*].app[0].startTime = 0.01s # time first session begins
**.stdHost[*].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[*].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[*].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[*].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[*].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[*].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[*].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[*].app[0].reconnectInterval = 30s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[*].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[*].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server.numApps = 1
*.server.app[0].typename = "TcpGenericServerApp"
*.server.app[0].localAddress = "" # local address; may be left empty ("")
*.server.app[0].localPort = 22 # localPort number to listen on
*.server.app[0].replyDelay = 0s #
*.server.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

[Config voipCliSrvTest]
description = "Link utilization test with VoIP Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,2,3,4,5,10,15,20,30,40,50,60,70,80,90,100,110}
**.conn1.delay = 1ms

# VoIP receiver
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "SimpleVoipReceiver"
**.stdHost[*].app[0].localPort = 2000
**.stdHost[*].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[*].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[*].app[0].emodelA = 5 # Advantage factor
**.stdHost[*].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[*].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[*].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[*].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[*].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server.numApps = ${numCli}
**.server.app[*].typename = "SimpleVoipSender"
**.server.app[*].localPort = -1
**.server.app[*].destPort = 2000
**.server.app[*].destAddress = "stdHost[" + string(index()) + "]"
**.server.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server.app[*].startTime = 0.01s # time of start sending
**.server.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config voipCliSrvTest_ext1]
description = "Link utilization test with VoIP Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=250,300}
**.conn1.delay = 1ms

# VoIP receiver
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "SimpleVoipReceiver"
**.stdHost[*].app[0].localPort = 2000
**.stdHost[*].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[*].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[*].app[0].emodelA = 5 # Advantage factor
**.stdHost[*].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[*].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[*].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[*].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[*].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server.numApps = ${numCli}
**.server.app[*].typename = "SimpleVoipSender"
**.server.app[*].localPort = -1
**.server.app[*].destPort = 2000
**.server.app[*].destAddress = "stdHost[" + string(index()) + "]"
**.server.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server.app[*].startTime = 0.01s # time of start sending

[Config voipCliSrvTestV2]
description = "Link delay test with VoIP Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,50}
**.conn1.delay = ${setDelay=10,100,1000,10000,100000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000,11000000,12000000,13000000,14000000,15000000,16000000,17000000,18000000,19000000,20000000,30000000,40000000,50000000,60000000,70000000,80000000,90000000,100000000,200000000,300000000,400000000,500000000,1000000000}ns

# VoIP receiver
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "SimpleVoipReceiver"
**.stdHost[*].app[0].localPort = 2000
**.stdHost[*].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[*].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[*].app[0].emodelA = 5 # Advantage factor
**.stdHost[*].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[*].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[*].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[*].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[*].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server.numApps = ${numCli}
**.server.app[*].typename = "SimpleVoipSender"
**.server.app[*].localPort = -1
**.server.app[*].destPort = 2000
**.server.app[*].destAddress = "stdHost[" + string(index()) + "]"
**.server.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server.app[*].startTime = 0.01s # time of start sending
**.server.app[*].stopTime = -1s # time of end of sending, -1 means forever


**.server.app[*].stopTime = -1s # time of end of sending, -1 means forever

[Config voipCliSrvTestV2_ext1]
description = "Link delay test with VoIP Application"
network = simpleNHost1ServerLinkUtilizationTest

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=1,50}
**.conn1.delay = ${setDelay=600000000,700000000,800000000,900000000}ns

# VoIP receiver
**.stdHost[*].numApps = 1
**.stdHost[*].app[0].typename = "SimpleVoipReceiver"
**.stdHost[*].app[0].localPort = 2000
**.stdHost[*].app[0].emodelIe = 5 # Equipment impairment factor
**.stdHost[*].app[0].emodelBpl = 10 # Packet-loss robustness factor
**.stdHost[*].app[0].emodelA = 5 # Advantage factor
**.stdHost[*].app[0].emodelRo = 93.2 # Basic signal-to-noise ratio
**.stdHost[*].app[0].playoutDelay = 10ms # initial delay for beginning playout after receiving the first packet
**.stdHost[*].app[0].adaptivePlayoutDelay = false # if true, adjust playoutDelay after each talkspurt
**.stdHost[*].app[0].bufferSpace = 20 # buffer size in packets
**.stdHost[*].app[0].mosSpareTime = 1s # spare time before calculating MOS (after calculated playout time of last packet)

# VoIP sender
**.server.numApps = ${numCli}
**.server.app[*].typename = "SimpleVoipSender"
**.server.app[*].localPort = -1
**.server.app[*].destPort = 2000
**.server.app[*].destAddress = "stdHost[" + string(index()) + "]"
**.server.app[*].talkPacketSize = 40B # size of talk packets in bytes
**.server.app[*].talkspurtDuration = weibull(1.423s, 0.824s)
**.server.app[*].silenceDuration = weibull(0.899s, 1.089s)
**.server.app[*].packetizationInterval = 1ms # interval between sending voice packets
**.server.app[*].startTime = 0.01s # time of start sending
**.server.app[*].stopTime = -1s # time of end of sending, -1 means forever


**.server.app[*].stopTime = -1s # time of end of sending, -1 means forever