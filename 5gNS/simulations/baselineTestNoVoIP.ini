[General]
sim-time-limit=250s
num-rngs = 1
seed-0-mt = 5
output-scalar-file-append = false
**.vector-recording = true
record-eventlog = false

*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true

#num-rngs = 2

**.tcpType = "TCP"

# tcp general settings
**.tcp.advertisedWindow = 65535                      # in bytes, corresponds with the maximal receiver buffer capacity (Note: normally, NIC queues should be at least this size)
**.tcp.delayedAcksEnabled = false                    # delayed ACK algorithm (RFC 1122) enabled/disabled
**.tcp.nagleEnabled = true                           # Nagle's algorithm (RFC 896) enabled/disabled
**.tcp.limitedTransmitEnabled = false                # Limited Transmit algorithm (RFC 3042) enabled/disabled (can be used for TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl)
**.tcp.increasedIWEnabled = false                    # Increased Initial Window (RFC 3390) enabled/disabled
**.tcp.sackSupport = false                           # Selective Acknowledgment (RFC 2018, 2883, 3517) support (header option) (SACK will be enabled for a connection if both endpoints support it)
**.tcp.windowScalingSupport = false                  # Window Scale (RFC 1323) support (header option) (WS will be enabled for a connection if both endpoints support it)
**.tcp.timestampSupport = false                      # Timestamps (RFC 1323) support (header option) (TS will be enabled for a connection if both endpoints support it)
**.tcp.mss = 1452                                    # Maximum Segment Size (RFC 793) (header option)
**.tcp.tcpAlgorithmClass = "TcpReno"                 # TCPReno/TCPTahoe/TCPNewReno/TCPNoCongestionControl/DumbTCP
#**.tcp.recordStats = true 							 # recording of seqNum etc. into output vectors enabled/disable

**.transmissionState.result-recording-modes = -vector
**.queueLength.result-recording-modes = -vector
**.queueingTime.result-recording-modes = -vector
**.ppp[*].queue.packetReceived.result-recording-modes = -vector(packetBytes)
**.tcpRcvQueueBytes.result-recording-modes = -vector

[Config baselineTestNoVoIP10]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=30}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..9].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..9].app[0].localAddress = ""
*.stdHost[0..9].app[0].localPort = -1 # port number to listen on
*.stdHost[0..9].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..9].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..9].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..9].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..9].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..9].app[0].requestLength = 800B # length of a request
*.stdHost[0..9].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..9].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..9].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..9].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..9].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..9].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[10..19].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[10..19].app[0].localAddress = "" # may be left empty ("")
**.stdHost[10..19].app[0].localPort = -1 # port number to listen on
**.stdHost[10..19].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[10..19].app[0].connectPort = 1042 # port number to connect to
**.stdHost[10..19].app[0].dataTransferMode = "object"
**.stdHost[10..19].app[0].startTime = 0.01s # time first session begins
**.stdHost[10..19].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[10..19].app[0].idleInterval = 1s
**.stdHost[10..19].app[0].requestLength = 200B # length of a request
**.stdHost[10..19].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[10..19].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[10..19].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[10..19].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[10..19].app[0].manifest_size = 100000
**.stdHost[10..19].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[10..19].app[0].video_duration = 300s # video length in seconds
**.stdHost[10..19].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Remote Shell Client
**.stdHost[20..29].app[0].typename = "TcpSimpleSshApp"
**.stdHost[20..29].app[0].localAddress = "" # local address or empty ("")
**.stdHost[20..29].app[0].localPort = -1 # local port number
**.stdHost[20..29].app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost[20..29].app[0].connectPort = 22  # port number to connect to
**.stdHost[20..29].app[0].startTime = 0.01s # time first session begins
**.stdHost[20..29].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[20..29].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[20..29].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[20..29].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[20..29].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[20..29].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[20..29].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[20..29].app[0].reconnectInterval = 1s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[20..29].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[20..29].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 1
*.server2.app[*].typename = "TcpGenericServerApp"
*.server2.app[*].localAddress = "" # local address; may be left empty ("")
*.server2.app[*].localPort = 22 # localPort number to listen on
*.server2.app[*].replyDelay = 0s #
*.server2.app[*].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[*].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false
*.server3.numApps = 0

[Config baselineTestNoVoIP20]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=60}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..19].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..19].app[0].localAddress = ""
*.stdHost[0..19].app[0].localPort = -1 # port number to listen on
*.stdHost[0..19].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..19].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..19].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..19].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..19].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..19].app[0].requestLength = 800B # length of a request
*.stdHost[0..19].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..19].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..19].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..19].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..19].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..19].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[20..39].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[20..39].app[0].localAddress = "" # may be left empty ("")
**.stdHost[20..39].app[0].localPort = -1 # port number to listen on
**.stdHost[20..39].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[20..39].app[0].connectPort = 1042 # port number to connect to
**.stdHost[20..39].app[0].dataTransferMode = "object"
**.stdHost[20..39].app[0].startTime = 0.01s # time first session begins
**.stdHost[20..39].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[20..39].app[0].idleInterval = 1s
**.stdHost[20..39].app[0].requestLength = 200B # length of a request
**.stdHost[20..39].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[20..39].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[20..39].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[20..39].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[20..39].app[0].manifest_size = 100000
**.stdHost[20..39].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[20..39].app[0].video_duration = 300s # video length in seconds
**.stdHost[20..39].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Remote Shell Client
**.stdHost[40..59].app[0].typename = "TcpSimpleSshApp"
**.stdHost[40..59].app[0].localAddress = "" # local address or empty ("")
**.stdHost[40..59].app[0].localPort = -1 # local port number
**.stdHost[40..59].app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost[40..59].app[0].connectPort = 22  # port number to connect to
**.stdHost[40..59].app[0].startTime = 0.01s # time first session begins
**.stdHost[40..59].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[40..59].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[40..59].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[40..59].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[40..59].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[40..59].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[40..59].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[40..59].app[0].reconnectInterval = 1s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[40..59].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[40..59].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 1
*.server2.app[*].typename = "TcpGenericServerApp"
*.server2.app[*].localAddress = "" # local address; may be left empty ("")
*.server2.app[*].localPort = 22 # localPort number to listen on
*.server2.app[*].replyDelay = 0s #
*.server2.app[*].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[*].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false
*.server3.numApps = 0

[Config baselineTestNoVoIP30]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=90}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..29].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..29].app[0].localAddress = ""
*.stdHost[0..29].app[0].localPort = -1 # port number to listen on
*.stdHost[0..29].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..29].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..29].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..29].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..29].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..29].app[0].requestLength = 800B # length of a request
*.stdHost[0..29].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..29].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..29].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..29].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..29].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..29].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[30..59].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[30..59].app[0].localAddress = "" # may be left empty ("")
**.stdHost[30..59].app[0].localPort = -1 # port number to listen on
**.stdHost[30..59].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[30..59].app[0].connectPort = 1042 # port number to connect to
**.stdHost[30..59].app[0].dataTransferMode = "object"
**.stdHost[30..59].app[0].startTime = 0.01s # time first session begins
**.stdHost[30..59].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[30..59].app[0].idleInterval = 1s
**.stdHost[30..59].app[0].requestLength = 200B # length of a request
**.stdHost[30..59].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[30..59].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[30..59].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[30..59].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[30..59].app[0].manifest_size = 100000
**.stdHost[30..59].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[30..59].app[0].video_duration = 300s # video length in seconds
**.stdHost[30..59].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Remote Shell Client
**.stdHost[60..89].app[0].typename = "TcpSimpleSshApp"
**.stdHost[60..89].app[0].localAddress = "" # local address or empty ("")
**.stdHost[60..89].app[0].localPort = -1 # local port number
**.stdHost[60..89].app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost[60..89].app[0].connectPort = 22  # port number to connect to
**.stdHost[60..89].app[0].startTime = 0.01s # time first session begins
**.stdHost[60..89].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[60..89].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[60..89].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[60..89].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[60..89].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[60..89].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[60..89].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[60..89].app[0].reconnectInterval = 1s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[60..89].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[60..89].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 1
*.server2.app[*].typename = "TcpGenericServerApp"
*.server2.app[*].localAddress = "" # local address; may be left empty ("")
*.server2.app[*].localPort = 22 # localPort number to listen on
*.server2.app[*].replyDelay = 0s #
*.server2.app[*].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[*].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false
*.server3.numApps = 0

[Config baselineTestNoVoIP40]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=120}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..39].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..39].app[0].localAddress = ""
*.stdHost[0..39].app[0].localPort = -1 # port number to listen on
*.stdHost[0..39].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..39].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..39].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..39].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..39].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..39].app[0].requestLength = 800B # length of a request
*.stdHost[0..39].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..39].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..39].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..39].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..39].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..39].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[40..79].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[40..79].app[0].localAddress = "" # may be left empty ("")
**.stdHost[40..79].app[0].localPort = -1 # port number to listen on
**.stdHost[40..79].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[40..79].app[0].connectPort = 1042 # port number to connect to
**.stdHost[40..79].app[0].dataTransferMode = "object"
**.stdHost[40..79].app[0].startTime = 0.01s # time first session begins
**.stdHost[40..79].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[40..79].app[0].idleInterval = 1s
**.stdHost[40..79].app[0].requestLength = 200B # length of a request
**.stdHost[40..79].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[40..79].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[40..79].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[40..79].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[40..79].app[0].manifest_size = 100000
**.stdHost[40..79].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[40..79].app[0].video_duration = 300s # video length in seconds
**.stdHost[40..79].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Remote Shell Client
**.stdHost[80..119].app[0].typename = "TcpSimpleSshApp"
**.stdHost[80..119].app[0].localAddress = "" # local address or empty ("")
**.stdHost[80..119].app[0].localPort = -1 # local port number
**.stdHost[80..119].app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost[80..119].app[0].connectPort = 22  # port number to connect to
**.stdHost[80..119].app[0].startTime = 0.01s # time first session begins
**.stdHost[80..119].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[80..119].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[80..119].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[80..119].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[80..119].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[80..119].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[80..119].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[80..119].app[0].reconnectInterval = 1s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[80..119].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[80..119].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 1
*.server2.app[*].typename = "TcpGenericServerApp"
*.server2.app[*].localAddress = "" # local address; may be left empty ("")
*.server2.app[*].localPort = 22 # localPort number to listen on
*.server2.app[*].replyDelay = 0s #
*.server2.app[*].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[*].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false
*.server3.numApps = 0

[Config baselineTestNoVoIP50]
description = "Fully utilize the link with all possible applications MOS check. Changed File Download config"
network = baselineTest

sim-time-limit=400s

output-vector-file = "${resultdir}/${configname}/${configname}-${runnumber}.vec"
output-scalar-file = "${resultdir}/${configname}/${configname}-${runnumber}.sca"

**.crcMode = "computed"

*.numStandardHosts = ${numCli=150}

**.conn1.delay = 1ms

*.stdHost[*].numApps = 1
*.server0.numApps = 1
*.server1.numApps = 1
#*.server2.numApps = 1

# File download client
*.stdHost[0..49].app[0].typename = "TcpFileDownloadApp"
*.stdHost[0..49].app[0].localAddress = ""
*.stdHost[0..49].app[0].localPort = -1 # port number to listen on
*.stdHost[0..49].app[0].connectAddress = "server0" # server address (may be symbolic)
*.stdHost[0..49].app[0].connectPort = 1042 # port number to connect to
*.stdHost[0..49].app[0].startTime = 0.01s # time first session begins
*.stdHost[0..49].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
*.stdHost[0..49].app[0].numRequestsPerSession = 1 # number of requests sent per session
*.stdHost[0..49].app[0].requestLength = 800B # length of a request
*.stdHost[0..49].app[0].replyLength = 10MiB # length of a reply
*.stdHost[0..49].app[0].thinkTime = 0.01s # time gap between requests
*.stdHost[0..49].app[0].idleInterval = 1s # time gap between sessions
*.stdHost[0..49].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
*.stdHost[0..49].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.stdHost[0..49].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# File download server

*.server0.app[0].typename = "TcpGenericServerApp"
*.server0.app[0].localAddress = "" # local address; may be left empty ("")
*.server0.app[0].localPort = 1042 # localPort number to listen on
*.server0.app[0].replyDelay = 0s #
*.server0.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server0.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Video client
**.stdHost[50..99].app[0].typename = "TCPVideoStreamCliApp"
**.stdHost[50..99].app[0].localAddress = "" # may be left empty ("")
**.stdHost[50..99].app[0].localPort = -1 # port number to listen on
**.stdHost[50..99].app[0].connectAddress = "server1" # server address (may be symbolic)
**.stdHost[50..99].app[0].connectPort = 1042 # port number to connect to
**.stdHost[50..99].app[0].dataTransferMode = "object"
**.stdHost[50..99].app[0].startTime = 0.01s # time first session begins
**.stdHost[50..99].app[0].stopTime = -1s # time of finish sending, 0 means infinity
**.stdHost[50..99].app[0].idleInterval = 1s
**.stdHost[50..99].app[0].requestLength = 200B # length of a request
**.stdHost[50..99].app[0].reconnectInterval = 1s # if connection breaks, waits this much before trying to reconnect
**.stdHost[50..99].app[0].numRequestsPerSession = 1 # number of requests sent per session
**.stdHost[50..99].app[0].thinkTime = 1000s # time gap between requests
**.stdHost[50..99].app[0].video_packet_size_per_second = "500 1000 1500 3000" # how many kbits are required for 1 second of video for each representation (quality levels)
**.stdHost[50..99].app[0].manifest_size = 100000
**.stdHost[50..99].app[0].video_buffer_max_length = 40s # buffer max length in seconds
**.stdHost[50..99].app[0].video_duration = 300s # video length in seconds
**.stdHost[50..99].app[0].segment_length = 5s # video segment length in seconds

# Video server
*.server1.app[0].typename = "TcpGenericServerApp"
*.server1.app[0].localAddress = "" # local address; may be left empty ("")
*.server1.app[0].localPort = 1042 # localPort number to listen on
*.server1.app[0].replyDelay = 0s #
*.server1.app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server1.app[0].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

# Remote Shell Client
**.stdHost[100..149].app[0].typename = "TcpSimpleSshApp"
**.stdHost[100..149].app[0].localAddress = "" # local address or empty ("")
**.stdHost[100..149].app[0].localPort = -1 # local port number
**.stdHost[100..149].app[0].connectAddress = "server2" # server address (may be symbolic)
**.stdHost[100..149].app[0].connectPort = 22  # port number to connect to
**.stdHost[100..149].app[0].startTime = 0.01s # time first session begins
**.stdHost[100..149].app[0].stopTime = -1s # time of finishing sending, negative values mean forever
**.stdHost[100..149].app[0].numCommands = 1 # user types this many commands in a session
**.stdHost[100..149].app[0].commandLength = 10B # commands are this many characters (plus Enter)
**.stdHost[100..149].app[0].keyPressDelay = 0.05s # delay between keypresses
**.stdHost[100..149].app[0].commandOutputLength = 500B # commands produce this much output
**.stdHost[100..149].app[0].thinkTime = 1s # user waits this much before starting to type new command
**.stdHost[100..149].app[0].idleInterval = 1s # time gap between sessions
**.stdHost[100..149].app[0].reconnectInterval = 1s # if connection breaks, user waits this much before trying to reconnect
**.stdHost[100..149].app[0].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
**.stdHost[100..149].app[0].stopOperationTimeout = 2s # timeout value for lifecycle stop operation

# SSH server
*.server2.numApps = 1
*.server2.app[*].typename = "TcpGenericServerApp"
*.server2.app[*].localAddress = "" # local address; may be left empty ("")
*.server2.app[*].localPort = 22 # localPort number to listen on
*.server2.app[*].replyDelay = 0s #
*.server2.app[*].stopOperationExtraTime = -1s # extra time after lifecycle stop operation finished
*.server2.app[*].stopOperationTimeout  = 2s # timeout value for lifecycle stop operation

*.server2.tcp.recordStats = true
**.stdHost[*].tcp.recordStats = false
**.server*.tcp.recordStats = false
*.server3.numApps = 0
